<!doctype html>
<meta charset=utf-8>
<meta name="timeout" content="long">
<title>Relay canvas via PeerConnections</title>
<script src=/resources/testharness.js></script>
<script src=/resources/testharnessreport.js></script>
<script src="RTCPeerConnection-helper.js"></script>
<script>
  'use strict';

// This test checks that canvas capture works relayed between several peer connections.

function GreenFrameWebGL(width, height) {
  const canvas =
      Object.assign(document.createElement('canvas'), {width, height});
  const ctx = canvas.getContext('webgl');
  if (ctx === null) return;
  requestAnimationFrame(function draw () {
    ctx.clearColor(0.0, 1.0, 0.0, 1.0);
    ctx.clear(ctx.COLOR_BUFFER_BIT);
    requestAnimationFrame(draw);
  });
  return canvas.captureStream();
}



promise_test(async t => {

  // Build a chain
  // canvas -track-> pc1 -network-> pc_relay_in -track->
  //       pc_relay_out -network-> pc2 -track-> video
  const pc1 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  const pc_relay_in = new RTCPeerConnection();
  t.add_cleanup(() => pc_relay_in.close());

  const pc_relay_out = new RTCPeerConnection();
  t.add_cleanup(() => pc_relay_out.close());
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc2.close());

  // Attach canvas to pc1.
  const stream = GreenFrameWebGL(640, 480);
  const [track] = stream.getTracks();
  pc1.addTrack(track);

  const v = document.createElement('video');
  v.autoplay = true;

  // Setup pc1->pc_relay_in video stream.
  const haveTrackEvent1 = new Promise(r => pc_relay_in.ontrack = r);
  exchangeIceCandidates(pc1, pc_relay_in);
  await pc1.setLocalDescription();
  await pc_relay_in.setRemoteDescription(pc1.localDescription);
  await pc_relay_in.setLocalDescription();
  await pc1.setRemoteDescription(pc_relay_in.localDescription);

  // Plug output of pc_relay_in to pc_relay_out.
  pc_relay_out.addTrack((await haveTrackEvent1).track);

  // Setup pc_relay_out->pc2 video stream.
  const haveTrackEvent2 = new Promise(r => pc2.ontrack = r);
  exchangeIceCandidates(pc_relay_out, pc2);
  await pc_relay_out.setLocalDescription();
  await pc2.setRemoteDescription(pc_relay_out.localDescription);
  await pc2.setLocalDescription();
  await pc_relay_out.setRemoteDescription(pc2.localDescription);

  // Display pc2 received track in video element.
  v.srcObject = new MediaStream([(await haveTrackEvent2).track]);
  await new Promise(r => v.onloadedmetadata = r);

  // Wait some time to ensure that frames got through.
  await new Promise(resolve => t.step_timeout(resolve, 1000));

  // Uses Helper.js GetVideoSignal to query |v| pixel value at a certain position.
  const pixel_value = getVideoSignal(v).toFixed();

  // Expected value computed based on GetVideoSignal code, which takes green pixel data
  // with coefficient 0.72.
  assert_true(0.72*255 - 2 < pixel_value && pixel_value < 0.72*255 + 2);
  }, "Two PeerConnections relaying a canvas source");
</script>
